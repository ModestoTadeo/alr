import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Stack, TextField } from "@mui/material";
import { useCallback, useEffect, useMemo, useState } from "react";
import { useFieldArray, useFormContext } from "react-hook-form";
import { useStepper } from "./StepperContext.js";
import { StepperCTAButton } from "./StepperCTAButton.js";
import { deserializeRegExp, mapPersonalDataToObject } from "./utils.js";
import { useWidget } from "./WidgetContext.js";
const validatePersonalData = (inputs) => inputs.reduce((acc, { name, required, value }) => {
    if (required?.pattern &&
        !deserializeRegExp(required.pattern).test(value ?? "")) {
        return {
            ...acc,
            [name]: {
                success: false,
                message: required.message,
            },
        };
    }
    return {
        ...acc,
        [name]: {
            success: true,
        },
    };
}, {});
export default function StepContentCustomData({ stepIndex }) {
    const { control: c, setValue } = useFormContext();
    const { fields, update } = useFieldArray({
        control: c,
        name: "personalData",
    });
    const [errors, setErrors] = useState();
    const [externallyValidating, setExternallyValidating] = useState(false);
    const onChange = useCallback((field, value, index) => {
        update(index, {
            ...field,
            value,
        });
    }, [fields]);
    const { eventHandlers, callbacks } = useWidget();
    const { handleNext } = useStepper();
    useEffect(() => {
        eventHandlers.onRouteChange({
            route: "step_personal_data",
        });
    }, [eventHandlers.onRouteChange]);
    useEffect(() => {
        eventHandlers.onPersonalDataUpdate({
            ...mapPersonalDataToObject(fields),
        });
    }, [eventHandlers.onPersonalDataUpdate, setErrors, fields]);
    const validationResult = useMemo(() => validatePersonalData(fields), [fields]);
    useEffect(() => {
        const result = Object.entries(validationResult).find(([_, { success }]) => success);
        if (result) {
            setErrors({ ...errors, [result[0]]: result[1] });
        }
    }, [validationResult]);
    const onContinue = useCallback(async () => {
        const isInternallyValid = Object.values(validationResult).every((result) => result.success);
        if (isInternallyValid) {
            setExternallyValidating(true);
            const externalValidationResult = await callbacks.validatePersonalData(fields);
            const isExternallyValid = Object.values(externalValidationResult ?? {}).every((result) => result?.success);
            setExternallyValidating(false);
            if (isExternallyValid) {
                handleNext(stepIndex);
            }
            else {
                setErrors(externalValidationResult);
            }
        }
        else {
            setErrors(validationResult);
        }
    }, [handleNext, stepIndex, validationResult]);
    const validateField = useCallback((key) => {
        if (errors && errors[key]?.success === false) {
            return {
                hasError: true,
                message: errors[key]?.message ?? "",
            };
        }
        return {
            hasError: false,
        };
    }, [errors]);
    return (_jsx(Stack, { direction: "column", alignItems: "stretch", justifyContent: "space-around", spacing: 3, sx: { pt: 1, pb: 3, px: 3.5 }, children: _jsx(Stack, { direction: "column", spacing: 2.5, textAlign: "center", children: _jsxs(Stack, { direction: "column", justifyContent: "center", alignItems: "stretch", spacing: 1, children: [_jsx(Stack, { direction: "row", flexWrap: "wrap", gap: 2, sx: { pb: 2 }, children: fields.map((field, i) => {
                            const { hasError, message } = validateField(field.name);
                            return (_jsx(TextField, { name: field.name, "data-testid": `input-${field.name}`, fullWidth: true, required: !field.optional, disabled: field.disabled, label: field.label, type: "text", error: hasError, helperText: message, value: field.value ?? "", onChange: ({ target }) => onChange(field, target.value, i), sx: {
                                    ...(field.size === "half"
                                        ? {
                                            width: "calc(50% - 8px)",
                                        }
                                        : {}),
                                } }, `input-${field.name}-${i}`));
                        }) }), _jsx(StepperCTAButton, { loading: externallyValidating, onClick: onContinue, children: "Continue" })] }) }) }));
}
