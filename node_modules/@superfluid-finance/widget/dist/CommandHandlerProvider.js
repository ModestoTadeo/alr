import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useMemo } from "react";
import { CommandHandlerContext, } from "./CommandHandlerContext.js";
import { useCommandHandlerReducer } from "./commandHandlingReducer.js";
import { CommandMapper } from "./CommandMapper.js";
import { ContractWriteManager, } from "./ContractWriteManager.js";
import { isDefined } from "./utils.js";
export function CommandHandlerProvider({ children }) {
    const [{ status, commands, sessionId, writeIndex }, dispatch] = useCommandHandlerReducer();
    const [contractWrites, contractWriteResults] = useMemo(() => {
        const contractWrites_ = commands
            .map((x) => x.contractWrites)
            .flat()
            .filter(isDefined);
        const contractWritesResults_ = contractWrites_
            .map((x) => x.result)
            .filter(isDefined);
        return [contractWrites_, contractWritesResults_];
    }, [commands]);
    const handleNextWrite = useCallback((writeIndex) => void dispatch({ type: "set write index", payload: writeIndex + 1 }), [dispatch]);
    const submitCommands = useCallback((commands) => void dispatch({ type: "set commands", payload: commands }), [dispatch]);
    const reset = useCallback(() => void dispatch({ type: "reset" }), [dispatch]);
    const onContractWrites = useCallback(({ commandId, contractWrites }) => void dispatch({
        type: "set contract writes",
        payload: {
            commandId,
            contractWrites,
        },
    }), [dispatch]);
    const onContractWriteResult = useCallback((result) => {
        void dispatch({
            type: "set contract write result",
            payload: {
                commandId: result.contractWrite.commandId,
                writeId: result.contractWrite.id,
                result,
            },
        });
        if (result.transactionResult.isSuccess &&
            result.contractWrite.id === contractWrites[writeIndex]?.id) {
            handleNextWrite(writeIndex);
        }
    }, [dispatch, writeIndex, contractWrites, handleNextWrite]);
    const contextValue = useMemo(() => ({
        status,
        commands,
        contractWrites,
        contractWriteResults,
        sessionId,
        submitCommands,
        reset,
        writeIndex,
        handleNextWrite,
    }), [
        status,
        commands,
        contractWrites,
        contractWriteResults,
        sessionId,
        submitCommands,
        reset,
        writeIndex,
        handleNextWrite,
    ]);
    return (_jsxs(CommandHandlerContext.Provider, { value: contextValue, children: [typeof children === "function" ? children(contextValue) : children, commands.map((cmd) => (_jsx(CommandMapper, { command: cmd, onMapped: onContractWrites }, cmd.id))), contractWrites.map((contractWrite, writeIndex_) => (_jsx(ContractWriteManager, { prepare: writeIndex_ === writeIndex, contractWrite: contractWrite, onChange: onContractWriteResult }, contractWrite.id)))] }));
}
