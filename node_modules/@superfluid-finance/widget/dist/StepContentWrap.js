import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Collapse, Fade, Input, Link, Paper, Stack, Typography, useTheme, } from "@mui/material";
import { useCallback, useEffect, useMemo, useState, } from "react";
import { Controller, useFormContext } from "react-hook-form";
import { zeroAddress } from "viem";
import { useBalance } from "wagmi";
import { UpgradeIcon } from "./previews/CommandPreview.js";
import { useStepper } from "./StepperContext.js";
import { StepperCTAButton } from "./StepperCTAButton.js";
import { TokenAvatar } from "./TokenAvatar.js";
import { mapFlowRateToDefaultWrapAmount, mapPersonalDataToObject, } from "./utils.js";
import { useWidget } from "./WidgetContext.js";
const WrapCard = ({ children, token, formattedTokenBalance, dataTest, }) => {
    return (_jsxs(Paper, { sx: {
            display: "grid",
            gridTemplateColumns: "1fr auto",
            alignItems: "center",
            px: 2.5,
            py: 1.5,
            rowGap: 0.75,
        }, children: [children, token && (_jsxs(Stack, { "data-testid": `${dataTest}-wrap-card`, component: Paper, variant: "outlined", direction: "row", alignItems: "center", spacing: 0.5, title: token.address, sx: { pl: 1.25, pr: 2, py: 1, borderRadius: 0.5 }, children: [_jsx(TokenAvatar, { "data-testid": `${dataTest}-icon`, tokenInfo: token, sx: { width: 24, height: 24 } }), _jsx(Typography, { "data-testid": `${dataTest}-symbol`, variant: "body1", children: token.symbol })] })), _jsx(Typography, { "data-testid": `${dataTest}-balance`, variant: "caption", align: "right", color: "text.secondary", sx: {
                    visibility: formattedTokenBalance ? "visible" : "hidden",
                    gridColumn: "1/3",
                }, children: `Balance: ${formattedTokenBalance}` })] }));
};
export default function StepContentWrap({ stepIndex }) {
    const theme = useTheme();
    const [focusedOnce, setFocusedOnce] = useState(false);
    const { control: c, setValue, watch, formState: { isValid, isValidating }, } = useFormContext();
    const { paymentDetails } = useWidget();
    const [accountAddress, paymentOptionWithTokenInfo, flowRate, personalData] = watch([
        "accountAddress",
        "paymentOptionWithTokenInfo",
        "flowRate",
        "personalData",
    ]);
    const superToken = paymentOptionWithTokenInfo?.superToken;
    const { getUnderlyingToken, getNativeAsset, eventHandlers } = useWidget();
    // Find the underlying token of the Super Token.
    const underlyingToken = useMemo(() => {
        if (!superToken) {
            return undefined;
        }
        const superTokenInfo = superToken.extensions.superTokenInfo;
        if (superTokenInfo.type === "Wrapper") {
            return getUnderlyingToken(superToken.chainId, superTokenInfo.underlyingTokenAddress);
        }
        if (superTokenInfo.type === "Native Asset") {
            return getNativeAsset(superToken.chainId);
        }
        return undefined;
    }, [superToken, getUnderlyingToken, getNativeAsset]);
    // TODO(KK): Probably don't need to do so much null-checking.
    const { data: underlyingTokenBalance } = useBalance(paymentOptionWithTokenInfo && underlyingToken && accountAddress
        ? {
            token: underlyingToken.address === zeroAddress
                ? undefined
                : underlyingToken.address,
            address: accountAddress,
            chainId: paymentOptionWithTokenInfo.paymentOption.chainId,
            formatUnits: underlyingToken.decimals,
        }
        : undefined);
    const { data: superTokenBalance } = useBalance(paymentOptionWithTokenInfo && superToken && accountAddress
        ? {
            token: superToken.address,
            address: accountAddress,
            chainId: paymentOptionWithTokenInfo.paymentOption.chainId,
            formatUnits: "ether", // Super Tokens are always 18 decimals.
        }
        : undefined);
    const showSkip = useMemo(() => {
        if (!paymentOptionWithTokenInfo || !superTokenBalance)
            return false;
        if (!flowRate?.amountEther)
            return false;
        const minWrapAmount = mapFlowRateToDefaultWrapAmount(paymentDetails.defaultWrapAmount, flowRate);
        return BigInt(superTokenBalance.value) >= minWrapAmount;
    }, [superTokenBalance, paymentOptionWithTokenInfo, flowRate]);
    const { handleNext } = useStepper();
    useEffect(() => {
        eventHandlers.onRouteChange({
            route: "step_wrap",
            ...mapPersonalDataToObject(personalData),
        });
    }, [eventHandlers.onRouteChange]);
    const onContinue = useCallback(() => {
        eventHandlers.onButtonClick({ type: "next_step" });
        handleNext(stepIndex);
    }, [handleNext, eventHandlers.onButtonClick, stepIndex]);
    const onSkipWrapping = useCallback(() => {
        eventHandlers.onButtonClick({ type: "skip_step" });
        setValue("wrapAmountInUnits", "");
        handleNext(stepIndex);
    }, [handleNext, setValue, eventHandlers.onButtonClick, stepIndex]);
    const onInputFocus = () => setFocusedOnce(true);
    return (_jsxs(Stack, { direction: "column", alignItems: "stretch", justifyContent: "space-around", spacing: 3, sx: { pt: 1, pb: 3, px: 3.5 }, children: [_jsx(Controller, { control: c, name: "wrapAmountInUnits", render: ({ field: { value, onChange, onBlur }, fieldState: { isTouched }, }) => (_jsxs(Stack, { direction: "column", justifyContent: "center", alignItems: "center", children: [_jsx(WrapCard, { dataTest: "underlying", token: underlyingToken, formattedTokenBalance: underlyingTokenBalance?.formatted, children: _jsx(Input, { "data-testid": "wrap-amount-input", disableUnderline: true, value: value, onChange: onChange, onBlur: onBlur, onFocus: onInputFocus, placeholder: "0", inputProps: {
                                    sx: {
                                        p: 0,
                                        ...theme.typography.h4,
                                    },
                                } }) }), _jsx(Stack, { component: Paper, sx: { p: 0.75, my: -1.25, transform: "rotate(90deg)" }, children: _jsx(UpgradeIcon, { fontSize: "small" }) }), _jsx(WrapCard, { dataTest: "super", token: superToken, formattedTokenBalance: superTokenBalance?.formatted, children: _jsx(Input, { "data-testid": "wrap-amount-mirror-amount", disableUnderline: true, value: value, onChange: onChange, onBlur: onBlur, onFocus: onInputFocus, placeholder: "0", inputProps: {
                                    sx: {
                                        p: 0,
                                        ...theme.typography.h4,
                                    },
                                } }) }), _jsx(Collapse, { in: focusedOnce || isTouched, timeout: 400, children: _jsx(Fade, { in: focusedOnce || isTouched, timeout: 400, children: _jsxs(Typography, { "data-testid": "we-recommend-message", variant: "caption", color: "text.secondary", sx: { mt: 0.75, alignSelf: "start" }, children: ["We recommend wrapping at least", " ", paymentDetails.defaultWrapAmount.multiplier, " ", paymentDetails.defaultWrapAmount.period ?? flowRate.period, paymentDetails.defaultWrapAmount.multiplier > 1
                                            ? "s"
                                            : "", " ", "of the subscription amount."] }) }) })] })) }), _jsxs(Stack, { direction: "column", spacing: 2.5, textAlign: "center", children: [_jsxs(Stack, { direction: "column", justifyContent: "center", alignItems: "stretch", spacing: 1, children: [_jsx(StepperCTAButton, { disabled: !isValid || isValidating, onClick: onContinue, children: "Continue" }), showSkip && (_jsx(StepperCTAButton, { variant: "outlined", color: "primary", onClick: onSkipWrapping, children: "Skip this step" }))] }), _jsx(Link, { "data-testid": "why-wrap-tokens-button", underline: "hover", href: "https://help.superfluid.finance/en/articles/7969656-why-do-i-need-to-wrap-tokens", target: "_blank", children: "Why do I need to wrap tokens?" })] })] }));
}
