import { formatEther, getAddress, parseEther } from "viem";
import { z } from "zod";
import { chainIdSchema } from "./SupportedNetwork.js";
import { timePeriods } from "./TimePeriod.js";
export const addressSchema = z
    .string()
    .trim()
    .transform((value, ctx) => {
    try {
        return getAddress(value);
    }
    catch {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "Not an address.",
            fatal: true,
        });
        return z.NEVER;
    }
});
export const tokenSchema = z.object({
    address: addressSchema,
});
export const etherAmountSchema = z
    .string()
    .trim()
    .transform((x, ctx) => {
    try {
        return formatEther(parseEther(x));
    }
    catch {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "Not an ether amount.",
            fatal: true,
        });
        return z.NEVER;
    }
});
export const flowRateSchema = z.object({
    amountEther: etherAmountSchema,
    period: z.enum(timePeriods),
});
export const paymentOptionSchema = z
    .object({
    receiverAddress: addressSchema,
    chainId: chainIdSchema,
    superToken: tokenSchema,
    transferAmountEther: etherAmountSchema
        .refine((x) => parseEther(x) > 0n, {
        message: "Upfront transfer amount must be greater than 0 when specified.",
    })
        .optional(),
    flowRate: flowRateSchema
        .refine((x) => parseEther(x.amountEther) > 0n, {
        message: "Flow rate must be greater than 0.",
    })
        .optional(),
    userData: z
        .string()
        .trim()
        .transform((x) => x.toString())
        .optional(),
})
    .refine((data) => !data.transferAmountEther ||
    Boolean(data.transferAmountEther && data.flowRate), {
    path: ["transferAmount"],
    message: "The upfront payment can only be defined with a fixed flow rate.",
});
