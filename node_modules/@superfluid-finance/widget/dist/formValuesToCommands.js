import { nanoid } from "nanoid";
import { formatUnits, parseEther, parseUnits, zeroAddress, } from "viem";
export const formValuesToCommands = (values) => {
    const { network: { id: chainId }, accountAddress, wrapAmountInUnits, enableAutoWrap, flowRate, paymentOptionWithTokenInfo: { paymentOption, superToken, underlyingToken: underlyingTokenInfo, }, } = values;
    const superTokenAddress = superToken.address;
    const commands = [];
    const isWrapperSuperToken = superToken.extensions.superTokenInfo.type === "Wrapper";
    const _isNativeAssetSuperToken = superToken.extensions.superTokenInfo.type === "Native Asset";
    // TODO(KK): Clean-up the bangs.
    if (isWrapperSuperToken) {
        const underlyingToken = {
            isNativeAsset: false,
            address: superToken.extensions.superTokenInfo.underlyingTokenAddress,
            decimals: underlyingTokenInfo.decimals,
        };
        const amountWeiFromUnderlyingTokenDecimals = parseUnits(wrapAmountInUnits, underlyingToken.decimals);
        const amountWeiFromSuperTokenDecimals = parseEther(wrapAmountInUnits); // Super Tokens always have 18 decimals.
        if (amountWeiFromUnderlyingTokenDecimals !== 0n) {
            commands.push({
                id: nanoid(),
                type: "Wrap into Super Tokens",
                chainId: chainId,
                superTokenAddress,
                accountAddress,
                underlyingToken,
                amountInUnits: formatUnits(amountWeiFromUnderlyingTokenDecimals, underlyingToken.decimals),
                amountWeiFromUnderlyingTokenDecimals,
                amountWeiFromSuperTokenDecimals,
            });
        }
        if (enableAutoWrap && underlyingToken?.address) {
            commands.push({
                id: nanoid(),
                type: "Enable Auto-Wrap",
                chainId: chainId, // TODO(KK): validate the type in form schema
                superTokenAddress,
                accountAddress,
                underlyingTokenAddress: underlyingToken.address,
            });
        }
    }
    if (_isNativeAssetSuperToken) {
        const amountWeiFromSuperTokenDecimals = parseEther(wrapAmountInUnits); // Super Tokens always have 18 decimals.
        const amountWeiFromUnderlyingTokenDecimals = parseEther(wrapAmountInUnits); // We assume native assets also always have 18 decimals.
        commands.push({
            id: nanoid(),
            type: "Wrap into Super Tokens",
            chainId: chainId,
            superTokenAddress,
            accountAddress,
            underlyingToken: {
                isNativeAsset: true,
                address: zeroAddress,
                decimals: 18,
            },
            amountInUnits: wrapAmountInUnits,
            amountWeiFromUnderlyingTokenDecimals,
            amountWeiFromSuperTokenDecimals,
        });
    }
    commands.push({
        id: nanoid(),
        type: "Subscribe",
        chainId,
        superTokenAddress,
        accountAddress,
        receiverAddress: paymentOption.receiverAddress,
        transferAmountWei: parseEther(paymentOption.transferAmountEther ?? "0"),
        flowRate: {
            amountWei: parseEther(flowRate.amountEther),
            period: flowRate.period,
            modifyBehaviour: values.modifyFlowRateBehaviour,
        },
        userData: paymentOption.userData ?? "0x",
    });
    return Object.freeze(commands);
};
