import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import CloseIcon_ from "@mui/icons-material/Close.js";
import { Alert, Box, Collapse, IconButton, List, ListSubheader, Stack, Typography, } from "@mui/material";
import { useCallback, useEffect } from "react";
import { useFormContext } from "react-hook-form";
import { useCommandHandler } from "./CommandHandlerContext.js";
import ContractWriteButton from "./ContractWriteButton.js";
import { ContractWriteStatus } from "./ContractWriteStatus.js";
import { normalizeIcon } from "./helpers/normalizeIcon.js";
import { useStepper } from "./StepperContext.js";
import { mapPersonalDataToObject } from "./utils.js";
import { useWidget } from "./WidgetContext.js";
const CloseIcon = normalizeIcon(CloseIcon_);
export function StepContentTransactions({ stepIndex }) {
    const { watch } = useFormContext();
    const [personalData] = watch(["personalData"]);
    const { handleBack, handleNext, setActiveStep, totalSteps } = useStepper();
    const { contractWrites, contractWriteResults, writeIndex, handleNextWrite: handleNextWrite_, } = useCommandHandler(); // Cleaner to pass with props.
    const { eventHandlers } = useWidget();
    useEffect(() => {
        eventHandlers.onRouteChange({
            route: "transactions",
            ...mapPersonalDataToObject(personalData),
        });
    }, [eventHandlers.onRouteChange]);
    useEffect(() => {
        if (writeIndex > 0 && writeIndex === contractWriteResults.length) {
            // TODO(KK): Check for success statuses. Maybe if not everything is a success, provide an explicit continue button.
            setActiveStep(totalSteps - 1); // i.e. all transactions handled
        }
    }, [writeIndex, contractWriteResults, handleNext, totalSteps]);
    const onBack = useCallback(() => {
        eventHandlers.onButtonClick({
            type: "back_transactions",
        });
        handleBack(stepIndex);
    }, [handleBack, eventHandlers.onButtonClick, stepIndex]);
    const total = contractWrites.length;
    const lastWriteIndex = Math.max(total - 1, 0);
    const isLastWrite = writeIndex === lastWriteIndex;
    const currentResult = contractWriteResults[Math.min(writeIndex, lastWriteIndex)];
    const handleNextWrite = useCallback(() => handleNextWrite_(writeIndex), [handleNextWrite_, writeIndex]);
    const showErrorAlert = Boolean(currentResult &&
        currentResult.currentError &&
        currentResult.currentError.shortMessage);
    return (_jsxs(Stack, { children: [_jsx(Stack, { alignItems: "end", children: _jsx(IconButton, { edge: "start", size: "medium", onClick: onBack, "aria-label": "back", sx: (theme) => ({ color: theme.palette.text.secondary, mr: -1 }), children: _jsx(CloseIcon, { fontSize: "medium" }) }) }), _jsxs(Stack, { direction: "column", spacing: 2.25, alignItems: "stretch", sx: { width: "100%", mt: -1 }, children: [_jsxs(Box, { textAlign: "center", children: [_jsx(Typography, { variant: "h5", component: "span", children: `You're almost there!` }), _jsx(Typography, { variant: "body2", color: "text.secondary", children: "Send the transactions from your wallet to finish your purchase." })] }), _jsx(List, { disablePadding: true, dense: true, subheader: _jsxs(ListSubheader, { "data-testid": "transaction-count", sx: { bgcolor: "transparent" }, children: ["Transactions (", total, ")"] }), children: contractWriteResults.map((result, index) => (_jsx(ContractWriteStatus, { result: result, index: index }, index.toString()))) }), _jsx(Collapse, { in: showErrorAlert, unmountOnExit: true, children: _jsx(Alert, { severity: "error", children: currentResult.currentError?.shortMessage }) }), currentResult && (_jsx(ContractWriteButton, { ...currentResult, isLastWrite: isLastWrite, handleNextWrite: handleNextWrite }))] })] }));
}
