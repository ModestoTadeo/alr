import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Box, Collapse, Fade, Portal, Step, StepButton, StepConnector, StepContent, Stepper as MUIStepper, } from "@mui/material";
import { useMemo, useRef } from "react";
import { useFormContext } from "react-hook-form";
import { CheckoutSummary } from "./CheckoutSummary.js";
import StepContentPaymentOption from "./StepContentPaymentOption.js";
import StepContentPersonalData from "./StepContentPersonalData.js";
import StepContentReview from "./StepContentReview.js";
import { StepContentTransactions } from "./StepContentTransactions.js";
import StepContentWrap from "./StepContentWrap.js";
import { StepperProvider } from "./StepperProvider.js";
import { useWidget } from "./WidgetContext.js";
export default function Stepper() {
    const { eventHandlers } = useWidget();
    const { watch, formState: { isValid }, } = useFormContext();
    const [paymentOptionWithTokenInfo, personalData] = watch([
        "paymentOptionWithTokenInfo",
        "personalData",
    ]);
    const [visibleSteps, walletConnectStep] = useMemo(() => {
        const superTokenType = paymentOptionWithTokenInfo?.superToken.extensions.superTokenInfo.type;
        const steps = [
            {
                optional: false,
                buttonText: "Select network and token",
                shortText: "Network & Token",
                Content: StepContentPaymentOption,
            },
            // Add wrap step only when Super Token has an underlying token.
            ...(superTokenType === "Wrapper" || superTokenType === "Native Asset"
                ? [
                    {
                        optional: true,
                        buttonText: "Wrap to Super Tokens",
                        shortText: "Wrap",
                        Content: StepContentWrap,
                    },
                ]
                : []),
            {
                optional: false,
                buttonText: "Review the transaction(s)",
                shortText: "Review",
                Content: StepContentReview,
            },
        ];
        const hasPersonalData = personalData.length > 0;
        if (hasPersonalData) {
            const isPersonalDataRequired = personalData.some((x) => !x.optional);
            const personalDataStep = {
                optional: !isPersonalDataRequired,
                buttonText: "Personal info",
                shortText: "Personal info",
                Content: StepContentPersonalData,
            };
            const summaryStep = steps.length - 1;
            const personalDataStepIndex = isPersonalDataRequired ? 0 : summaryStep;
            steps.splice(personalDataStepIndex, 0, personalDataStep);
            const walletConnectStep = isPersonalDataRequired ? 1 : 0;
            return [steps, walletConnectStep];
        }
        else {
            return [steps, 0];
        }
    }, [paymentOptionWithTokenInfo, personalData]);
    const container = useRef(null);
    const totalSteps = visibleSteps.length + 2; // Add confirm and success. TODO(KK): not clean...
    const transactionStep = totalSteps - 2;
    const summaryStep = totalSteps - 1;
    return (_jsx(StepperProvider, { totalSteps: totalSteps, initialStep: isValid ? visibleSteps.length - 1 : 0, walletConnectStep: walletConnectStep, children: ({ activeStep, setActiveStep, orientation }) => {
            const isTransacting = activeStep === transactionStep;
            const isFinished = activeStep === summaryStep;
            const isForm = !isTransacting && !isFinished;
            const visualActiveStep = Math.min(visibleSteps.length - 1, activeStep);
            return (_jsxs(_Fragment, { children: [_jsx(Collapse, { "data-testid": "widget-preview", in: isForm, appear: false, children: _jsx(Fade, { in: isForm, appear: false, children: _jsx(Box, { children: _jsx(MUIStepper, { orientation: orientation, activeStep: visualActiveStep, connector: orientation === "horizontal" ? _jsx(StepConnector, {}) : null, sx: {
                                        ...(orientation === "horizontal"
                                            ? {
                                                pt: 2.5,
                                                pb: 1,
                                                px: 3,
                                            }
                                            : {}),
                                    }, children: visibleSteps.map((step, index) => {
                                        const { Content: Content_ } = step;
                                        const Content = orientation === "vertical" ? (_jsx(StepContent, { children: _jsx(Content_, { stepIndex: index }) })) : activeStep === index ? (_jsx(Portal, { container: container.current, children: _jsx(Content_, { stepIndex: index }) })) : null;
                                        const labelText = orientation === "vertical"
                                            ? step.buttonText
                                            : step.shortText;
                                        return (_jsxs(Step, { "data-testid": `step-${index + 1}`, children: [_jsx(StepButton, { optional: step.optional, disabled: visualActiveStep <= index, "data-testid": `step-${index + 1}-button`, onClick: () => {
                                                        eventHandlers.onButtonClick({
                                                            type: "step_label",
                                                        });
                                                        setActiveStep(index);
                                                    }, sx: (theme) => ({
                                                        position: "relative",
                                                        width: "100%",
                                                        ...(orientation === "vertical"
                                                            ? {
                                                                "&:hover": {
                                                                    bgcolor: theme.palette.action.hover,
                                                                },
                                                            }
                                                            : {
                                                                pl: 0,
                                                            }),
                                                    }), children: labelText }), Content] }, index));
                                    }) }) }) }) }), _jsx(Collapse, { in: isForm, appear: false, unmountOnExit: false, children: _jsx(Fade, { in: isForm, appear: false, unmountOnExit: false, children: _jsx(Box, { ref: container }) }) }), _jsx(Collapse, { in: isFinished, unmountOnExit: true, children: _jsx(Fade, { in: isFinished, children: _jsx(Box, { sx: { m: 3 }, children: _jsx(CheckoutSummary, {}) }) }) }), _jsx(Collapse, { in: isTransacting, unmountOnExit: true, children: _jsx(Fade, { in: isTransacting, children: _jsx(Box, { sx: { mx: 3, mb: 3, mt: 2 }, children: _jsx(StepContentTransactions, { stepIndex: transactionStep }) }) }) })] }));
        } }));
}
