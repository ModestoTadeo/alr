import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import ReplayIcon_ from "@mui/icons-material/Replay.js";
import SkipNextIcon_ from "@mui/icons-material/SkipNext.js";
import WarningAmberIcon_ from "@mui/icons-material/WarningAmber.js";
import { LoadingButton } from "@mui/lab";
import { Button, Collapse, Stack } from "@mui/material";
import { useCallback, useEffect, useState } from "react";
import { useAccount, useNetwork, useSwitchNetwork } from "wagmi";
import { normalizeIcon } from "./helpers/normalizeIcon.js";
import { useWidget } from "./WidgetContext.js";
const ReplayIcon = normalizeIcon(ReplayIcon_);
const SkipNextIcon = normalizeIcon(SkipNextIcon_);
const WarningAmberIcon = normalizeIcon(WarningAmberIcon_);
export default function ContractWriteButton({ isLastWrite, handleNextWrite: handleNextWrite_, contractWrite, prepareResult, writeResult, transactionResult, currentError, }) {
    const { eventHandlers } = useWidget();
    const write = writeResult.write;
    const isLoading = prepareResult.isLoading ||
        writeResult.isLoading ||
        transactionResult.isLoading;
    const expectedChainId = contractWrite.chainId;
    const { chain } = useNetwork();
    const { switchNetwork } = useSwitchNetwork();
    const { connector } = useAccount();
    const needsToSwitchNetwork = expectedChainId !== chain?.id;
    const onSwitchNetworkButtonClick = useCallback(() => {
        eventHandlers.onButtonClick({ type: "switch_network" });
        switchNetwork?.(expectedChainId);
    }, [switchNetwork, expectedChainId, eventHandlers.onButtonClick]);
    const onContractWriteButtonClick = useCallback(() => {
        eventHandlers.onButtonClick({
            type: "invoke_transaction",
        });
        write?.();
    }, [write, eventHandlers.onButtonClick]);
    const onRetryTransactionButtonClick = useCallback(() => {
        eventHandlers.onButtonClick({
            type: "retry_gas_estimation",
        });
        prepareResult.refetch();
    }, [prepareResult.refetch, eventHandlers.onButtonClick]);
    const onForceTransactionButtonClick = useCallback(() => {
        eventHandlers.onButtonClick({
            type: "force_invoke_transaction",
        });
        write();
    }, [write, eventHandlers.onButtonClick]);
    const isPrepareError = Boolean(currentError &&
        currentError === prepareResult.error &&
        !prepareResult.isFetching);
    const [allowNextWriteButton, setAllowNextWriteButton] = useState(false);
    const showNextWriteButton = (allowNextWriteButton || transactionResult.isError) &&
        (!isLastWrite || connector?.id === "safe"); // Don't show the button for the last contract write, unless Gnosis Safe. It would be confusing to show the success screen when possibly the last TX fails.
    const onSkipButtonClick = useCallback(() => {
        eventHandlers.onButtonClick({
            type: "skip_to_next",
        });
        handleNextWrite_();
        setAllowNextWriteButton(false);
    }, [handleNextWrite_, eventHandlers.onButtonClick]);
    useEffect(() => {
        if (transactionResult.isLoading) {
            const timeoutId = setTimeout(() => {
                setAllowNextWriteButton(true);
            }, 30000); // After 30 seconds, the button appears as an escape hatch.
            return () => clearTimeout(timeoutId);
        }
        else {
            setAllowNextWriteButton(false);
        }
    }, [transactionResult.isLoading, onSkipButtonClick]);
    const showForceSendButton = Boolean(isPrepareError &&
        !prepareResult.isLoading &&
        write &&
        !writeResult.isLoading);
    const isWriteButtonDisabled = Boolean(isPrepareError || transactionResult.isSuccess || !write);
    const writeButtonText = transactionResult.isLoading
        ? "Waiting for transaction..."
        : writeResult.isLoading
            ? "Waiting for wallet..."
            : "Send transaction";
    const showRetryButton = Boolean(isPrepareError && !writeResult.isLoading);
    return (_jsx(Stack, { direction: "column", spacing: 1, children: needsToSwitchNetwork ? (_jsx(Button, { "data-testid": "switch-network-button", size: "large", variant: "contained", fullWidth: true, onClick: onSwitchNetworkButtonClick, children: "Switch network" })) : (_jsxs(_Fragment, { children: [showRetryButton ? (_jsx(Button, { variant: "contained", size: "large", fullWidth: true, onClick: onRetryTransactionButtonClick, endIcon: _jsx(ReplayIcon, {}), children: "Retry transaction gas estimation" })) : (_jsx(LoadingButton, { loadingPosition: "end", "data-testid": "transaction-button", size: "large", variant: "contained", fullWidth: true, disabled: isWriteButtonDisabled, onClick: onContractWriteButtonClick, loading: isLoading, children: writeButtonText })), _jsx(Collapse, { in: showNextWriteButton, unmountOnExit: true, children: _jsx(Button, { variant: "outlined", color: "primary", size: "medium", endIcon: _jsx(SkipNextIcon, {}), fullWidth: true, onClick: onSkipButtonClick, children: "Skip to next transaction" }) }), _jsx(Collapse, { in: showForceSendButton, unmountOnExit: true, children: _jsx(Button, { variant: "outlined", size: "medium", color: "error", startIcon: _jsx(WarningAmberIcon, {}), fullWidth: true, onClick: onForceTransactionButtonClick, children: "Force transaction to be sent" }) })] })) }));
}
